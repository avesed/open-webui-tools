"""
title: image generate
author: Avesed
version: 1.0
description: use given api for in chat LLM to generate image
"""

import requests
import json
import base64
import mimetypes
import io
import time
from pydantic import BaseModel, Field
from typing import Callable, Any, Optional
from fastapi import UploadFile
from open_webui.routers.files import upload_file_handler
from open_webui.models.users import Users


class Tools:
    # User input
    class Valves(BaseModel):
        api_key: str = Field(default="", description="API Key")
        api_url: str = Field(
            default="",
            description="API URL, dont add / at the end, e.g. https://api.openai.com/v1",
        )
        model: str = Field(
            default="", description="Model, exact model name, e.g. dall-e-3"
        )
        use_url_response: bool = Field(
            default=True,
            description="Use URL response format (otherwise base64)",
        )

    def __init__(self):
        self.valves = self.Valves()

    def _download_image_as_data_url(self, image_url: str) -> str:
        """Fetch image bytes from a URL and convert them into a data URL."""
        response = requests.get(image_url, timeout=60)
        if response.status_code != 200:
            raise ValueError(
                f"Error downloading image: {response.status_code}, {response.text}"
            )
        content_type = response.headers.get("content-type", "image/png")
        b64 = base64.b64encode(response.content).decode("utf-8")
        return f"data:{content_type};base64,{b64}"

    async def _save_image_and_get_public_url(self, request, data_url: str, user) -> str:
        # Parse data url
        header, b64data = data_url.split(",", 1)
        img_bytes = base64.b64decode(b64data)
        content_type = header.split(":")[1].split(";")[0]
        image_format = mimetypes.guess_extension(content_type) or ".png"
        # Create upload file
        file = UploadFile(
            file=io.BytesIO(img_bytes),
            filename=f"generated-image-{int(time.time())}{image_format}",
        )
        # Upload to owui
        file_item = upload_file_handler(
            request=request, file=file, metadata={}, process=False, user=user
        )
        if not file_item:
            raise ValueError("Failed to save image")
        # Get public url
        file_id = str(getattr(file_item, "id", ""))
        base_url = str(request.base_url).rstrip("/")
        relative_path = request.app.url_path_for("get_file_content_by_id", id=file_id)
        timestamp = int(time.time() * 1000)
        return f"{base_url}{relative_path}?t={timestamp}"

    async def generate_image(
        self,
        prompt: str,
        __user__: Optional[dict] = None,
        __request__=None,
        __event_emitter__: Optional[Callable[[dict], Any]] = None,
    ) -> str:
        """
        Generate an image based on the prompt and return url, LLM must use markdown to show user the image.

        :param prompt: Description of the image to generate
        """
        # Update owui
        if __event_emitter__:
            await __event_emitter__(
                {
                    "type": "status",
                    "data": {"description": "Generating image", "done": False},
                }
            )
        # Check config
        if not self.valves.api_key or not self.valves.api_url or not self.valves.model:
            raise ValueError("API Key, API URL, and Model are required")
        if not __request__ or not __user__:
            raise ValueError("Request and User are required")
        # Request image
        url = f"{self.valves.api_url}/images/generations"
        headers = {
            "Authorization": f"Bearer {self.valves.api_key}",
            "Content-Type": "application/json",
        }
        response_format = "url" if self.valves.use_url_response else "b64_json"
        data = {
            "model": self.valves.model,
            "prompt": prompt,
            "response_format": response_format,
        }
        api_response = requests.post(url, headers=headers, json=data, timeout=60)
        # Process response
        if api_response.status_code == 200:
            api_result = api_response.json()
            for i in api_result["data"]:
                public_url = None
                image_url = i.get("url")
                b64 = i.get("b64_json")

                if self.valves.use_url_response and image_url:
                    public_url = image_url
                else:
                    data_url = None
                    if b64:
                        data_url = f"data:image/png;base64,{b64}"
                    elif image_url:
                        data_url = self._download_image_as_data_url(image_url)
                    if data_url:
                        # Save image and get url
                        user = Users.get_user_by_id(__user__.get("id"))
                        public_url = await self._save_image_and_get_public_url(
                            __request__, data_url, user
                        )
                if public_url:
                    md = f"![generated image]({public_url})"
                    # Update owui
                    if __event_emitter__:
                        await __event_emitter__(
                            {
                                "type": "status",
                                "data": {
                                    "description": "Image generated successfully",
                                    "done": True,
                                },
                            }
                        )
                        # Show image
                        await __event_emitter__(
                            {"type": "message", "data": {"content": md}}
                        )
                    return f"""Here is the generated image, LLM must use markdown to show the user:\n{md}."""
            raise ValueError("Error: No base64 or URL data found in the API response")
        else:
            raise ValueError(
                f"Error getting image: {api_response.status_code}, {api_response.text}"
            )
